import matplotlib.pyplot as plt
from scipy.optimize import minimize

# Define physical parameters
gamma = 1.0  # Friction coefficient
D = 0.05     # Reduce diffusion coefficient to enhance differences

# 1. Define double-well potential and its derivatives
def potential(x):
    """Double-well potential U(x) = (x^2 - 1)^2"""
    return (x**2 - 1)**2

def force(x):
    """Force F(x) = -U'(x)"""
    return -4 * x * (x**2 - 1)

def drift(x):
    """Drift term A(x) = F(x) / gamma"""
    return force(x) / gamma

def drift_prime(x):
    """Derivative of drift term A'(x)"""
    return (-12 * x**2 + 4) / gamma

# 2. Discretized action
def get_action(path, dt, action_type='OM'):
    """Calculate discrete action of path"""
    x = path
    x_dot = np.diff(x) / dt
    x_mid = (x[:-1] + x[1:]) / 2  # Midpoints for evaluating A(x) and A'(x)
    
    A = drift(x_mid)
    A_prime = drift_prime(x_mid)
    
    # FW Lagrangian
    lagrangian_fw = (x_dot - A)**2 / (4 * D)
    
    if action_type == 'FW':
        action = np.sum(lagrangian_fw * dt)
    elif action_type == 'OM':
        # OM correction term
        lagrangian_om_corr = 0.5 * A_prime
        action = np.sum((lagrangian_fw + lagrangian_om_corr) * dt)
    else:
        raise ValueError("action_type must be 'FW' or 'OM'")
        
    return action

# 3. Numerical optimization to find instanton
# Time and path settings
T_total = 8.0  # Increase total time
N_points = 201  # Increase number of path points
dt = T_total / (N_points - 1)
time = np.linspace(0, T_total, N_points)

# Initial path guess (straight line from -1 to +1)
initial_path = np.linspace(-1, 1, N_points)

# Optimization functions
def objective_fw(p):
    return get_action(p, dt, 'FW')

def objective_om(p):
    return get_action(p, dt, 'OM')

# Run optimization
# Fix start and end points of path
cons = ({'type': 'eq', 'fun': lambda x: x[0] + 1},
        {'type': 'eq', 'fun': lambda x: x[-1] - 1})

print("Minimizing FW action...")
result_fw = minimize(objective_fw, initial_path, constraints=cons, method='SLSQP', 
                     options={'maxiter': 1000, 'ftol': 1e-9})
path_fw = result_fw.x
print("FW minimization successful:", result_fw.success)
print("FW action value:", result_fw.fun)

print("Minimizing OM action...")
# Use FW result as initial guess for OM
result_om = minimize(objective_om, path_fw, constraints=cons, method='SLSQP',
                     options={'maxiter': 1000, 'ftol': 1e-9})
path_om = result_om.x
print("OM minimization successful:", result_om.success)
print("OM action value:", result_om.fun)


# 4. Plotting
plt.figure(figsize=(10, 6))
x_plot = np.linspace(-1.5, 1.5, 200)
U_plot = potential(x_plot)

plt.plot(x_plot, U_plot, 'k-', label='Potential $U(x)=(x^2-1)^2$')
plt.plot(path_fw, potential(path_fw), 'r.--', label='FW Instanton')
plt.plot(path_om, potential(path_om), 'b.--', label='OM Instanton')

plt.title('Most Probable Paths (Instantons) in a Double-Well Potential')
plt.xlabel('Position $x$')
plt.ylabel('Potential Energy $U(x)$')
plt.ylim(-0.2, 2)
plt.legend()
plt.grid(True)
plt.show()

# Plot path vs. time
plt.figure(figsize=(10, 6))
plt.plot(time, path_fw, 'r-', label='FW Instanton')
plt.plot(time, path_om, 'b-', label='OM Instanton')
plt.axhline(-1, color='k', linestyle='--', alpha=0.5)
plt.axhline(1, color='k', linestyle='--', alpha=0.5)
plt.title('Path vs. Time')
plt.xlabel('Time $t$')
plt.ylabel('Position $x(t)$')
plt.legend()
plt.grid(True)
plt.show()
```
```python
import numpy as np
import matplotlib.pyplot as plt

# Use the same physical parameters and potential function as simulation 1
gamma = 1.0
D = 0.25     # Moderate diffusion coefficient, balancing transition rate and rarity
T_total = 40.0  # Further increase total time to ensure complete equilibrium
N_points = 801  # Further increase time resolution
dt = T_total / (N_points - 1)
time = np.linspace(0, T_total, N_points)

def potential(x):
    return (x**2 - 1)**2

def drift(x):
    return -4 * x * (x**2 - 1) / gamma

def drift_prime(x):
    """Derivative of drift term A'(x)"""
    return (-12 * x**2 + 4) / gamma

# Simple calculation of OM instanton path (for plotting)
def get_simple_om_instanton():
    """Calculate simplified OM instanton path for visualization"""
    from scipy.optimize import minimize
    
    def get_action(path, dt):
        x = path
        x_dot = np.diff(x) / dt
        x_mid = (x[:-1] + x[1:]) / 2
        A = drift(x_mid)
        A_prime = drift_prime(x_mid)
        lagrangian_fw = (x_dot - A)**2 / (4 * D)
        lagrangian_om_corr = 0.5 * A_prime
        action = np.sum((lagrangian_fw + lagrangian_om_corr) * dt)
        return action
    
    # Simplified optimization
    initial_path = np.linspace(-1, 1, N_points)
    cons = ({'type': 'eq', 'fun': lambda x: x[0] + 1},
            {'type': 'eq', 'fun': lambda x: x[-1] - 1})
    
    try:
        result = minimize(lambda p: get_action(p, dt), initial_path, 
                         constraints=cons, method='SLSQP', 
                         options={'maxiter': 1000, 'ftol': 1e-6})
        if result.success:
            return result.x
    except:
        pass
    
    # If optimization fails, return a simple S-shaped curve
    t_norm = np.linspace(0, 1, N_points)
    return np.tanh(4 * (t_norm - 0.5))

# 1. Langevin simulator
def langevin_trajectory(x0, T, dt):
    """Generate a Langevin trajectory"""
    n_steps = int(T / dt)
    t = np.linspace(0, T, n_steps + 1)
    x = np.zeros(n_steps + 1)
    x[0] = x0
    
    # Pre-generate all random numbers
    noise = np.random.normal(0, 1, n_steps)
    
    for i in range(n_steps):
        A = drift(x[i])
        stochastic_term = np.sqrt(2 * D * dt) * noise[i]
        x[i+1] = x[i] + A * dt + stochastic_term
        
    return t, x

# 2. Generate large number of trajectories
num_trajectories = 2000  # Increase total trajectories to get sufficient transition samples
trajectories = []
transition_paths = []
print(f"Simulating {num_trajectories} trajectories...")
for i in range(num_trajectories):
    t, x = langevin_trajectory(x0=-1.0, T=T_total, dt=dt)
    trajectories.append(x)
    # Record successful transition paths (increase threshold for stricter definition of transition)
    if x[-1] > 0.3:  # Increase threshold to ensure truly reaching right potential well
        transition_paths.append(x)
print(f"Found {len(transition_paths)} transition paths.")
print(f"Transition rate: {len(transition_paths)/num_trajectories*100:.1f}%")

trajectories = np.array(trajectories)
transition_paths = np.array(transition_paths)

# 3. Plotting
plt.figure(figsize=(12, 8))

# Plot potential background
x_plot = np.linspace(-2, 2, 200)
U_plot = potential(x_plot)
plt.plot(x_plot, U_plot, 'k-', alpha=0.3, label='Potential $U(x)$')

# First plot transition trajectories (at bottom layer)
if len(transition_paths) > 0:
    # Only plot some transition trajectories to avoid excessive density
    num_to_plot = min(len(transition_paths), 25)  # Display at most 25 green trajectories
    for i in range(num_to_plot):
